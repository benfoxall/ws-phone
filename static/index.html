<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ws-phone</title>
    <style media="screen">
      #status {white-space: pre}
    </style>
  </head>
  <body>
    <h1>websocket phone</h1>

    <h2 id="status">_</h2>

    <canvas id="c" width="600" height="300"></canvas>

    <script>
      var status_el = document.querySelector('#status')
      var ctx = c.getContext('2d')

      var ws = new WebSocket(location.origin.replace(/^http/, 'ws') + '/browser')
      ws.binaryType = 'arraybuffer'


      var AudioContext = window.AudioContext || window.webkitAudioContext
      var context = new AudioContext()


      ws.onopen = function() {
        console.log("OPEN")
        // status_el.innerText = 'connected'
      }
      ws.onclose = function() {
        console.log("CLOSED")
        status_el.innerText = 'disconnected'
      }

      var configured = false
      var time = 0
      ws.onmessage = function(event){

        if(!configured) {
          var config = JSON.parse(event.data)
          console.log(config)
          status_el.innerText = `Connected.
Call ${config.number}
Then enter "${config.digits}" when prompted`
          configured = true

        } else {
          // console.log("message", event)

          time = Math.max(context.currentTime, time)

          var input = new Int16Array(event.data)

          if(input.length) {

            var buffer = context.createBuffer(1, input.length, 16000)
            var data = buffer.getChannelData(0)
            for (var i = 0; i < data.length; i++) {
              data[i] = input[i] / 32767
              // data[i] = Math.random()
            }

            var source = context.createBufferSource()
            source.buffer = buffer
            source.connect(context.destination)
            source.start(time += buffer.duration)

            ctx.fillStyle = '#f08'
            ctx.clearRect(300,0,300,300)
            for (var i = 0; i < 300; i++) {
              ctx.fillRect(300 + i, 150, 1, 300*input[i]/32767)
            }

          }

        }

      }


      //
      navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
      })
      .then( stream => {


        var source = context.createMediaStreamSource(stream)

        var processor = context.createScriptProcessor(1024, 1, 1)


        var downsampled = new Int16Array(2048)
        var downsample_offset = 0

        function process_samples(){

          while(downsample_offset > 320) {
            var output = downsampled.slice(0, 320)

            downsampled.copyWithin(0, 320)
            downsample_offset -= 320

            ctx.fillStyle = 'red'
            if(ws.readyState == ws.OPEN) {
              ctx.fillStyle = '#08f'
              ws.send(output.buffer)
            }

            ctx.clearRect(0,0,300,300)
            for (var i = 0; i < 300; i++) {
              ctx.fillRect(i, 150, 1, 300*downsampled[i]/32767)
            }


          }
        }

        var ratio = context.sampleRate / 16000

        processor.onaudioprocess = (audioProcessingEvent) => {

          var inputBuffer = audioProcessingEvent.inputBuffer
          var outputBuffer = audioProcessingEvent.outputBuffer

          var inputData = inputBuffer.getChannelData(0)
          var outputData = outputBuffer.getChannelData(0)

          // sketchy downsample
          for (var i = 0; i < inputData.length; i += ratio) {
            var sidx = Math.floor(i)
            var tidx = Math.floor(i/ratio)
            downsampled[downsample_offset + tidx] = inputData[sidx] * 32767

          }

          downsample_offset += ~~(inputData.length/ratio)

          if(downsample_offset > 320) {
            process_samples()
          }

          // console.log(downsample_offset)

          for (var sample = 0; sample < inputBuffer.length; sample++) {
            // make output equal to the same as the input
            outputData[sample] = inputData[sample];

            // add noise to each output sample
            outputData[sample] = 0;// += ((Math.random() * 2) - 1) * 0.2;
          }
        }

        source.connect(processor)
        processor.connect(context.destination)

      })
    </script>
  </body>
</html>
